# Q3. 1차원 뿌요 뿌요

# 뿌요뿌요는 여러 색깔의 뿌요(블럭)들을 적절히 배치하여, 가능한 많은 뿌요를 터트리는 것이 목적인 낙하형 퍼즐 게임이다.
# 원래 게임은 2차원 보드에서 진행이 되지만 이 문제에서는 1차원 보드라고 가정하자.
# 현재 보드위에 N개의 뿌요가 늘어선 상태이며, 같은 색의 뿌요가 M개 이상 서로 붙어있으면 터진다.
# 여러 뿌요가 동시에 터지는 조건을 만족할 때는 그 중 가장 왼쪽에 있는 뿌요들부터 터지기 시작한다
# 보드의 초기 상태를 나타낸 문자열이 주어졌을 때, 더 이상 뿌요가 터지지 않게 되었을 때 보드의 상태를 구해보자

# 예제 설명
# 첫 번째 예제에서 보드의 상태는 ABCCVCCDA 이고, 뿌요가 터짐에 따라 ABBCCDA, ACCDA, ADA 순서로 보드의 상태가 변하게 된다.

# 입력
# 첫째줄에 두 정수 N, M이 공백을 두고 주어진다
# 둘째 줄에 길이 N의 뿌요 문자열 S가 주어진다. 뿌요 문자열의 각 문자는 해당 위치에 놓여있는 뿌요의 색깔을 의미한다.

# 출력
# 뿌요가 터지고 난 후 최종 사애의 뿌요 문자열을 출력한다. 만약 모든 뿌요가 터져서 남아있는 뿌요가 없는 경우 CLEAR!를 출력한다.

'''
9 2
ABCCBCCDA
-------------
ADA

10 3
ABCCCBBAAA
--------------
CLEAR!
'''
# <스택, 예외처리 디테일 잡기 >

import sys
input = sys.stdin.readline

N, M = map(int, input().split())
S = input().rstrip()
Q = []
Q.append(('', 1))

S += 'z'
for c in S:
    if Q[-1][0] != c:
        if M <= Q[-1][1]:
            top = Q[-1][0]
            while top == Q[-1][0]:
                Q.pop()
    if Q[-1][0] == c:
        Q.append((c, Q[-1][1] + 1))
    else:
        Q.append((c, 1))
Q.pop()

if len(Q) > 1:
    for c, n in Q:
        print(c, end='')
else:
    print("CLEAR!")
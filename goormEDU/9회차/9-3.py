# Q. 순환하는 수로

# 구름이는 도시의 수도 시스템을 총괄하는 관리자이다. 현재 도시에는 물을 보관하는 물탱크와 물탱크끼리 연결하는 수로가 각각 N개씩 존재한다.
# 물탱크는 관리의 편의를 위해 1번부터 N번까지의 번호가 붙어 있고, 수로는 서로 다른 두 물탱크를 연결하고 있다,
# 모든 물탱크는 수로로 서로 연결되어 있고, 두 물탱크 사이에는 최대 하나의 수로만 연결되어 있다,
# 도시의 물은 흐르지 않으며 녹조가 생기기 때문에, 항상 물이 순환하도록 유지하는 것이 중요하다,
# 그래서 구름이는 현재 수도 시스템에서 물이 순환할 수 있는 경로를 하나 찾고, 해당 수로를 이용해 물이 계속해서 순환 할 수 있게끔 하려고 한다,
# 모든 수로는 양방향으로 물이 흐르게 할 수 있으나, 한 번 물이 흐르기 시작한 뒤에는 두 방향 중 한 방향으로만 물을 보낼 수 있다,
# 이 때 어떤 수로들만을 이용해 물이 순환하는 경로를 만들 수 있다면, 이를 순환하는 수로라고 한다,
# 도시에 있는 수로이 정보가 주어졌을 때, 순환하는 수로에 포함되는 물탱크들을 출력하시오. 이러한 물탱크의 집합은 유일함이 보장된다,

# 입력
# 첫째 줄에는 정수 N이 주어진다,
# 다음 N개의 줄에는 수로가 연결하는 두 물탱크 번호 ui, Ui가 공백을 두고 주어진다,
# 서로 다른 두 물탱크 사이를 연결하는 수로의 개수는 최대 하나이다.

# 출력
# 첫째 줄에는 순환하는 수로에 포함된 물태크의 수를 출력한다,
# 둘째 줄에는 순환하는 수로를 구성하는 물탱크의 번호를 오름차순으로 공백을 두고 출력한다,

# < BFS/DFS , 정점의 수와 간선의 수가 같은 특수한 형태의 그래프>
'''
6
4 1
2 1
6 2
3 6
4 5
3 2
-----
3
2 3 6

6
2 5
4 6
3 5
3 1
2 3
5 6
----
3
2 3 5
'''

import sys

input = sys.stdin.readline

N = int(input())
G = [[] for _ in range(N + 1)]
V = [0 for _ in range(N + 1)]
for _ in range(N):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)

# 현재 방문한 정점을 기록하는 스택입니다.
ST = []
# 사이클의 시작점을 의미하는 변수입니다.
start = -1


def DFS(cur, prev):
    global start
    ST.append(cur)
    for next in G[cur]:
        if start != -1:
            return
        # 바로 직전 정점과는 사이클을 이룰 수 없으므로, 예외처리를 해줘야 합니다.
        if next == prev:
            continue
        # 다음 정점이 이미 방문한 정점인 경우, 해당 정점을 사이클의 시작점으로 설정하고 DFS를 탈출합니다.
        if V[next]:
            start = next
            return
        V[next] = 1
        DFS(next, cur)
    # 사이클의 시작 정점을 찾은 경우, 방문한 정점 목록을 보존해야 하므로 DFS를 더 수행하면 안 됩니다.
    if start != -1:
        return
    ST.pop()


V[1] = 1
DFS(1, 0)

# 현재 스택에는 사이클을 이루는 경로가 역순으로 저장되어 있습니다.
# 사이클의 시작 정점이 보일 때까지 스택에서 원소들을 뽑아줍니다.
ans = []
while 1:
    ans.append(ST[-1])
    ST.pop()
    if ans[-1] == start:
        break

ans.sort()
print(len(ans))
print(*ans)
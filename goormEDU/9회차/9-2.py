# Q.알파벳 트리 장난감

# 포화 이진 트리 형태의 알파벳 트리 장난감이 있다. 이 장난감의 각 노드에는 알파벳이 쓰여있고, 루트 노드의 윗부분에는 구멍이 나있다,
# 이 구멍을 통해 공을 넣으면 50%의 확률로 왼쪽 또는 오른쪽 자식 노드로 공이 굴러간다,
# 그렇게 공은 리프 노드에 도달할 때까지 굴러간다. 여기서 전체 장난감의 높이가 N일 때, 루트 노드의 높이는 1, 리프 노드의 높이는 N에 해당한다,
# 공이 한 번 들어간 노드는 불이 켜지기 때문에, 공이 어떤 경로를 통해 굴러내려왔는지 알 수 있다. 공을 한 번 굴리면 점수를 얻을 수 있는데,
# 각 알파벳의 점수를 A가 1점, B가 2점, ... , Z가 26점이라고 할 때 경로에 포함된 알파벳들의 점수 합이 곧 경로의 점수가 된다,
# 장난감에 공을 굴렀을 때 얻을 수 있는 점수의 최솟값과 최댓값을 각각 구해보자

# 예제 설명
# 첫 번째 예제의 경우 트리의 형태는 아래 그림과 같다.
# 이 때 점수의 최솟값을 얻는 경로는 빨간색으로 색칠된 경로이고, 최댓값을 얻는 경로는 파란색으로 색칠된 경로에 해당한다,
# 그림

# 입력
# 첫째 줄에 알파벳 트리 장난감의 높이 N이 주어진다
# 다음 N개의 줄에는 알파벳 트리 장난감의 노드에 적힌 문자가 주어진다, i번째 줄에는 2i-1개의 문자가 주어지고,
# 해당 높이의 가장 왼쪽에 위치한 노드에 적힌 문자부터 순서대로 주어진다,
#   - 3 <= N <= 20
#   - 주어지는 문자는 모두 알파벳 대문자이다,

# 출력
# 첫째 줄에는 공을 굴렸을 때 나올 수 있는 점수의 최솟값을 출력한다,
# 둘째 줄에는 공을 굴렸을 대 나올 수 있는 점수의 최댓값을 출력한다,

#< 트리, DFS>
'''
3
A
BC
DEFG
-------
7
11

4
K
WL
TZAL
YYWBNRJT
-----------
38
83
'''

import sys

input = sys.stdin.readline

N = int(input())
S = [[] for _ in range(N + 1)]
for i in range(1, N + 1):
    S[i] = input().rstrip()
ans1, ans2 = 9 ** 9, 0


def DFS(h, n, score):
    score += ord(S[h][n]) - ord('A') + 1
    if h < N:
        DFS(h + 1, n * 2, score)
        DFS(h + 1, n * 2 + 1, score)
    else:
        global ans1, ans2
        ans1 = min(ans1, score)
        ans2 = max(ans2, score)


DFS(1, 0, 0)
print(ans1, ans2, sep='\n')
# Q. 구름이의 여행 2

# 구름이가 사는 구름 나라는 N개의 섬으로 이루어져있다. 각 섬에는 1부터 N까지 번호가 붙어있고, 구름 나라는 사람들이
# 섬과 섬 사이를 편하게 이동할 수 있도록 다리를 M개 설치했다. 설치된 다리들은 아래 특징들을 만족한다.
# - 모든 다리는 단방향으로만 이동할 수 있다,
# - 서로 다른 두 섬을 잇는 다리는 최대 하나이다
# - 다리가 잇는 두 섬은 항상 다른섬이다.
# 구름이는 현재 K번 섬에 있고, 다른 섬들을 둘러본 뒤 다시 K번 섬으로 돌아오려한다, 그렇지만 오래돌아다니는 것은 피곤한 일이기 때문에,
# 구름이는 최소한의 다리만 거치는 경로를 택할것이다. 구름이를 도와 최소 몇 개의 다리를 거쳐서 원래 구름이가 있던 섬으로 돌아올 수 있을지 알아보자
# 다시 돌알올 수 있는 경로가 없는 경우에는 -1을 출력한다,
# 단, 구름이는 K번 섬 이외에 최소 하나 이상의 다른 섬을 방문해야한다.

# 예제설명
# 첫 번째 예제에서는 아래와 같이 구름 나라의 섬과 다리가 배치되어있다, 구름이는 현재 4번섬에 있다.
# 그림
# 4번 섬에서 출발한 구름이는 2번과 5번 섬으로 이동할 수 있다,
# 2번 섬으로 이동한 구름이는 더 이상 이동할 수 없지만, 5번 섬으로 이동한 구름이는 3번과 1번 섬을 거쳐서 다시 4번 섬으로 돌아올 수 있다,
# 이 경우 총 4개의 다리를 통과했고, 가능한 최소 개수이다,
# 두 번째 예제에서 아래와 같이 구름 나라의 섬과 다리가 배치되어 있다, 구름이는 현재 4번 섬에 있다,
# 그림
# 4번 섬에서 출발한 구름이는 2번 섬으로 이동할 수있고, 2번 섬에서 다른 섬으로 이동할 수 없다.
# 따라서 다시 4번 섬으로 돌아오는 것은 불가능하고, -1을 출력해야한다,

# 입력
# 첫째 줄에 섬의 개수 N과 다리의 개수 M, 그리고 구름이가 있는 섬의 번호 K가 공백을 두고 주어진다,
# 다음 M개의 줄에는 다리의 시작 점과 도착 섬을 의미하는 a, b가 공백을 두고 주어진다,
# - 서로 다른 두 다리의 시작점과 도착섬이 같은 경우는 없다,
# - 입력에 주어지는 수는 모두 정수

# 출력
# K번 섬에서 출발한 구름이가 최소 몇 개의 다리를 거쳐서 다시 K번 섬으로 도착할 수 있는지 출력하시오,
# 만약 구름이가 다시 돌아올 수 없다면 -1을 출력하시오,

#<BFS, BFS를 이용해서 사이클 찾기>
'''
5 6 4
1 2
1 4
3 1
4 2
4 5
5 3
------
4

5 6 4
1 2
1 3
3 2
4 2
5 1
5 4
--------
-1
'''

from collections import deque
import sys

input = sys.stdin.readline

N, M, K = map(int, input().split())
G = [[] for _ in range(N + 1)]
for _ in range(M):
    a, b = map(int, input().split())
    G[a].append(b)

D = [9 ** 9 for _ in range(N + 1)]
D[K] = 0
Q = deque()
Q.append(K)
ans = 9 ** 9

while Q:
    cur = Q.popleft()
    for next in G[cur]:
        # n_p에 해당하는 정점을 찾았을 때 답을 갱신합니다.
        if next == K:
            ans = min(ans, D[cur] + 1)
        if D[next] <= D[cur] + 1:
            continue
        D[next] = D[cur] + 1
        Q.append(next)

if ans == 9 ** 9:
    print(-1)
else:
    print(ans)